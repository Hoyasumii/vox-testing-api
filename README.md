# API - Sistema de Agendamento M√©dico

Sistema backend para agendamento m√©dico desenvolvido com NestJS, onde m√©dicos podem disponibilizar seus hor√°rios e pacientes podem realizar agendamentos.

## ÔøΩ Decis√£o Tecnol√≥gica: Por que NestJS ao inv√©s de .NET ou Java?
Eu acabei me aperfei√ßoando bastante na stack de Node.js com TypeScript e o ecossistema em si. Entretanto, h√° cerca de um ano, eu venho amadurecendo muito a forma de como eu vejo para se criar um projeto, e tenho muito interesse em poder ingressar para uma outra linguagem, s√≥ n√£o tive oportunidade.

Al√©m do mais, quando um projeto se inicia com a modelagem do sistema em si e o design do c√≥digo, a linguagem acaba n√£o fazendo muita diferen√ßa, pois a linguagem ub√≠qua prevalece e acaba se criando um √∫nico idioma. N√£o sei se faz sentido, mas quando o projeto acaba tendo a necessidade de ser robusto e ele √© constru√≠do nesse intuito, as barreiras entre frameworks e linguagens se tornam quase que nulas.

#### ‚úÖ **Escolhas Feitas**
- **NestJS vs Express**: Estrutura + DI + Decorators
- **Prisma vs TypeORM**: Developer experience + type safety
- **Zod vs class-validator**: Runtime safety + schema reuse
- **Redis vs In-memory**: Distributed caching + persistence
- **JWT vs Sessions**: Stateless + microservices ready

#### ‚öñÔ∏è **Trade-offs Considerados**
- **Performance vs Maintainability**: Optamos por c√≥digo limpo
- **Flexibility vs Convention**: NestJS opinions aceitas
- **Simplicity vs Features**: Features essenciais implementadas
- **Memory vs Speed**: Cache estrat√©gico implementado

## üé® Decis√µes de Design de C√≥digo

### Organiza√ß√£o de M√≥dulos

```
src/
‚îú‚îÄ‚îÄ modules/                    # M√≥dulos de dom√≠nio
‚îÇ   ‚îú‚îÄ‚îÄ auth/                  # Autentica√ß√£o isolada
‚îÇ   ‚îú‚îÄ‚îÄ users/                 # Gest√£o de usu√°rios
‚îÇ   ‚îú‚îÄ‚îÄ doctors/               # Dom√≠nio m√©dicos
‚îÇ   ‚îú‚îÄ‚îÄ schedules/             # Dom√≠nio agendamentos
‚îÇ   ‚îî‚îÄ‚îÄ availability/          # Dom√≠nio disponibilidade
‚îú‚îÄ‚îÄ shared/                    # C√≥digo compartilhado
‚îÇ   ‚îú‚îÄ‚îÄ guards/               # Guards reutiliz√°veis
‚îÇ   ‚îú‚îÄ‚îÄ interceptors/         # Interceptors globais
‚îÇ   ‚îú‚îÄ‚îÄ decorators/           # Decorators customizados
‚îÇ   ‚îî‚îÄ‚îÄ pipes/                # Pipes de valida√ß√£o
‚îî‚îÄ‚îÄ common/                   # Utilit√°rios comuns
    ‚îú‚îÄ‚îÄ dtos/                 # DTOs base
    ‚îú‚îÄ‚îÄ errors/               # Hierarquia de erros
    ‚îî‚îÄ‚îÄ types/                # Tipos compartilhados
```

### Conven√ß√µes de Nomenclatura

#### 1. **Arquivos e Classes**
```typescript
// Controllers: PascalCase + .controller.ts
export class ScheduleController {}

// Services: PascalCase + .service.ts  
export class ScheduleService {}

// DTOs: PascalCase + .dto.ts
export class CreateScheduleDto {}

// Entities: PascalCase (Prisma models)
export interface Schedule {}
```

#### 2. **M√©todos e Vari√°veis**
```typescript
// M√©todos: camelCase + verbo descritivo
async createSchedule(data: CreateScheduleDto) {}
async findAvailableSlots(filters: AvailabilityFilters) {}
async cancelScheduleById(id: string) {}

// Vari√°veis: camelCase + substantivo descritivo
const availableSlots = await this.findSlots();
const doctorSchedules = await this.repository.findByDoctor();
```

#### 3. **Constantes e Enums**
```typescript
// Constantes: SCREAMING_SNAKE_CASE
export const DEFAULT_PAGINATION_LIMIT = 20;
export const CACHE_TTL_MINUTES = 30;

// Enums: PascalCase
export enum ScheduleStatus {
  SCHEDULED = 'SCHEDULED',
  CANCELED = 'CANCELED',
  COMPLETED = 'COMPLETED'
}
```

### Padr√µes de Implementa√ß√£o

#### 1. **Error Handling Strategy**
```typescript
// Hierarquia de erros customizada
abstract class ApplicationError extends Error {
  abstract statusCode: number;
  abstract errorCode: string;
}

class ConflictError extends ApplicationError {
  statusCode = 409;
  errorCode = 'CONFLICT';
}

// Uso consistente em services
async createSchedule(data: CreateScheduleDto) {
  const hasConflict = await this.checkTimeConflict(data);
  
  if (hasConflict) {
    throw new ConflictError('Schedule time conflict detected');
  }
}
```

#### 2. **Response Standardization**
```typescript
// DTOs de resposta padronizados
export class ScheduleResponseDto {
  @ApiProperty() id: string;
  @ApiProperty() doctorId: string;
  @ApiProperty() patientId: string;
  @ApiProperty() dateTime: string;
  @ApiProperty() status: ScheduleStatus;
  @ApiProperty() createdAt: string;
  @ApiProperty() updatedAt: string;
}

// Pagina√ß√£o consistente
export class PaginatedResponseDto<T> {
  @ApiProperty() data: T[];
  @ApiProperty() pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}
```

#### 3. **Validation Patterns**
```typescript
// Schemas Zod reutiliz√°veis
export const UUIDSchema = z.string().uuid();
export const DateTimeSchema = z.string().datetime();
export const PaginationSchema = z.object({
  page: z.number().min(1).default(1),
  limit: z.number().min(1).max(100).default(20)
});

// Composi√ß√£o de schemas
export const CreateScheduleSchema = z.object({
  doctorId: UUIDSchema,
  dateTime: DateTimeSchema,
  patientNotes: z.string().optional()
});
```

### Design de API REST

#### 1. **RESTful Design Principles**
```typescript
// Recursos bem definidos
/auth                          # Autentica√ß√£o
/users                         # Usu√°rios gen√©ricos
/doctors                       # Recurso m√©dicos
/doctors/:id/availability      # Sub-recurso aninhado
/schedules                     # Agendamentos
/availability/slots            # Endpoint de busca especializado
```

#### 2. **HTTP Status Codes**
```typescript
// Uso sem√¢ntico correto
200 OK          // Sucesso em GET, PUT
201 Created     // Sucesso em POST
204 No Content  // Sucesso em DELETE
400 Bad Request // Validation errors
401 Unauthorized// Token inv√°lido/ausente
403 Forbidden   // Sem permiss√£o
404 Not Found   // Recurso n√£o encontrado
409 Conflict    // Conflito de agendamento
429 Too Many    // Rate limit exceeded
500 Internal    // Erro interno
```

#### 3. **Content Negotiation**
```typescript
// Headers padronizados
@Header('Content-Type', 'application/json')
@ApiProduces('application/json')
@ApiConsumes('application/json')

// Versionamento preparado
@Controller({ path: 'schedules', version: '1' })
```

### Database Design Patterns

#### 1. **Prisma Schema Organization**
```prisma
// Enums centralizados
enum UserType { DOCTOR PATIENT }
enum ScheduleStatus { SCHEDULED CANCELED COMPLETED }

// Models com relacionamentos claros
model User {
  id        String   @id @default(uuid())
  type      UserType @default(PATIENT)
  
  // Relacionamentos
  doctorProfile    Doctor?
  patientSchedules Schedule[] @relation("PatientSchedules")
  
  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
}
```

#### 2. **Migration Strategy**
```sql
-- Naming: timestamp_description_of_change
-- Example: 20250814124402_initial_migration

-- √çndices para performance
CREATE INDEX idx_doctor_availability_datetime 
ON "DoctorAvailability"(doctor_id, start_time, end_time);

CREATE INDEX idx_schedule_status_datetime 
ON "Schedule"(status, date_time);
```

### Testing Design Patterns

#### 1. **Test Organization**
```typescript
// Describe blocks estruturados
describe('ScheduleService', () => {
  describe('createSchedule', () => {
    it('should create schedule successfully', async () => {});
    it('should throw conflict error for overlapping times', async () => {});
    it('should validate doctor availability', async () => {});
  });
  
  describe('cancelSchedule', () => {
    it('should cancel own schedule as patient', async () => {});
    it('should cancel any schedule as doctor', async () => {});
    it('should throw forbidden for unauthorized cancel', async () => {});
  });
});
```

#### 2. **Mock Patterns**
```typescript
// Factory functions para testes
export const createMockUser = (overrides?: Partial<User>): User => ({
  id: 'uuid-mock',
  email: 'test@example.com',
  type: UserType.PATIENT,
  ...overrides
});

// Repository mocks consistentes
const mockScheduleRepository = {
  create: jest.fn(),
  findById: jest.fn(),
  findByDoctor: jest.fn()
};
```

### Performance Design Patterns

#### 1. **Lazy Loading Strategy**
```typescript
// Eager loading apenas quando necess√°rio
const scheduleWithRelations = await prisma.schedule.findUnique({
  where: { id },
  include: {
    doctor: { select: { id: true, user: { select: { name: true } } } },
    patient: { select: { id: true, user: { select: { name: true } } } }
  }
});

// Lazy loading para listas
const schedules = await prisma.schedule.findMany({
  select: { id: true, dateTime: true, status: true } // Apenas campos necess√°rios
});
```

#### 2. **Batch Operations**
```typescript
// Opera√ß√µes em lote quando poss√≠vel
async createMultipleAvailabilities(slots: CreateAvailabilityDto[]) {
  return this.prisma.doctorAvailability.createMany({
    data: slots,
    skipDuplicates: true
  });
}
```

### Security Design Patterns

#### 1. **Input Sanitization**
```typescript
// Sanitiza√ß√£o autom√°tica nos DTOs
export const CreateScheduleSchema = z.object({
  doctorId: z.string().uuid(), // UUID validation
  dateTime: z.string().datetime().refine(
    (date) => new Date(date) > new Date(), // Future date only
    { message: 'DateTime must be in the future' }
  ),
  notes: z.string().max(500).optional() // Length limit
});
```

#### 2. **Authorization Patterns**
```typescript
// Guards compostos para autoriza√ß√£o granular
@UseGuards(JwtAuthGuard, ResourceOwnerGuard)
async getMySchedules(@CurrentUser() user: User) {
  // Usu√°rio s√≥ acessa pr√≥prios agendamentos
}

@UseGuards(JwtAuthGuard, RolesGuard)
@Roles(UserType.DOCTOR)
async completeSchedule(@Param('id') id: string) {
  // Apenas m√©dicos podem completar agendamentos
}
```

## üöÄ Tecnologias Utilizadaso Desenvolvedor]**  
> *[Espa√ßo reservado para explicar a escolha do NestJS ao inv√©s de .NET, considerando fatores como experi√™ncia, ecosystem, performance, produtividade, etc.]*

## üèõÔ∏è Decis√µes de Arquitetura e Design

### Arquitetura Geral

Este projeto segue uma **arquitetura em camadas** inspirada em princ√≠pios de **Clean Architecture** e **Domain-Driven Design (DDD)**, adaptada para o contexto do NestJS:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    üì° CONTROLLERS LAYER                    ‚îÇ
‚îÇ  ‚Ä¢ Rotas REST API                                          ‚îÇ
‚îÇ  ‚Ä¢ Valida√ß√£o de entrada (DTOs + Zod)                       ‚îÇ
‚îÇ  ‚Ä¢ Documenta√ß√£o OpenAPI/Swagger                            ‚îÇ
‚îÇ  ‚Ä¢ Rate Limiting & Guards                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚¨áÔ∏è
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     üß† SERVICES LAYER                      ‚îÇ
‚îÇ  ‚Ä¢ L√≥gica de neg√≥cio                                       ‚îÇ
‚îÇ  ‚Ä¢ Regras de dom√≠nio                                       ‚îÇ
‚îÇ  ‚Ä¢ Orquestra√ß√£o entre reposit√≥rios                         ‚îÇ
‚îÇ  ‚Ä¢ Sistema de mensageria (PUB/SUB)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚¨áÔ∏è
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  üíæ REPOSITORIES LAYER                     ‚îÇ
‚îÇ  ‚Ä¢ Abstra√ß√£o de dados                                      ‚îÇ
‚îÇ  ‚Ä¢ Cache integrado (Redis)                                 ‚îÇ
‚îÇ  ‚Ä¢ Padr√£o Repository                                       ‚îÇ
‚îÇ  ‚Ä¢ Event-driven updates                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚¨áÔ∏è
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   üóÑÔ∏è DATABASE LAYER                        ‚îÇ
‚îÇ  ‚Ä¢ PostgreSQL (Prisma ORM)                                 ‚îÇ
‚îÇ  ‚Ä¢ Migrations & Schema management                          ‚îÇ
‚îÇ  ‚Ä¢ Performance otimizado com √≠ndices                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Principais Decis√µes Arquiteturais

#### 1. **Separation of Concerns (SoC)**
- **Controllers**: Apenas respons√°veis por receber requisi√ß√µes e retornar respostas
- **Services**: Cont√™m toda a l√≥gica de neg√≥cio e regras de dom√≠nio
- **Repositories**: Abstraem o acesso aos dados com cache integrado
- **DTOs**: Valida√ß√£o e transforma√ß√£o de dados de entrada/sa√≠da

#### 2. **Repository Pattern + Cache**
```typescript
// Exemplo da implementa√ß√£o
abstract class CacheableRepository<T> {
  // Cache autom√°tico em opera√ß√µes de leitura
  // Invalida√ß√£o inteligente em opera√ß√µes de escrita
  // PUB/SUB para sincroniza√ß√£o entre inst√¢ncias
}
```

**Benef√≠cios:**
- **Performance**: Cache Redis transparente
- **Escalabilidade**: Invalida√ß√£o distribu√≠da via PUB/SUB
- **Testabilidade**: Reposit√≥rios mock√°veis
- **Manutenibilidade**: Mudan√ßas de ORM isoladas

#### 3. **Event-Driven Architecture (Messaging)**
```typescript
// Sistema de eventos para desacoplamento
@Injectable()
export class ScheduleService {
  async createSchedule(data: CreateScheduleDto) {
    const schedule = await this.repository.create(data);
    
    // Evento disparado automaticamente
    this.eventBus.publish('schedule.created', schedule);
    return schedule;
  }
}
```

**Vantagens:**
- **Desacoplamento**: Servi√ßos n√£o dependem uns dos outros
- **Extensibilidade**: Novos listeners sem modificar c√≥digo existente
- **Auditoria**: Rastreamento de eventos de neg√≥cio
- **Integra√ß√µes futuras**: Facilita adi√ß√£o de notifica√ß√µes, emails, etc.

#### 4. **Type-Safe Validation com Zod**
```typescript
// DTOs tipados e validados
export const CreateScheduleSchema = z.object({
  doctorId: z.string().uuid(),
  dateTime: z.string().datetime(),
  patientNotes: z.string().optional()
});

export const CreateScheduleDto = createZodDto(CreateScheduleSchema);
```

**Benef√≠cios:**
- **Seguran√ßa**: Valida√ß√£o em runtime
- **DX**: IntelliSense completo
- **Documenta√ß√£o**: Schema autom√°tico no Swagger
- **Manutenibilidade**: Mudan√ßas propagadas automaticamente

### Design Patterns Implementados

#### 1. **Dependency Injection (DI)**
- Container IoC nativo do NestJS
- Facilita testes e mocking
- Baixo acoplamento entre componentes

#### 2. **Factory Pattern**
```typescript
// Factories para cria√ß√£o de objetos complexos
@Injectable()
export class ScheduleFactory {
  createFromAvailability(availability: DoctorAvailability, patientId: string) {
    // L√≥gica complexa de cria√ß√£o encapsulada
  }
}
```

#### 3. **Guard Pattern**
```typescript
// Prote√ß√£o de rotas com guards customizados
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles(UserType.DOCTOR)
export class DoctorController {
  // Apenas m√©dicos podem acessar
}
```

#### 4. **Decorator Pattern**
```typescript
// Decorators customizados para funcionalidades cross-cutting
@RateLimit({ requests: 5, windowMs: 60000 })
@ApiTags('Authentication')
@Controller('auth')
export class AuthController {}
```

### Estrat√©gias de Performance

#### 1. **Multi-Level Caching**
```typescript
// Cache em m√∫ltiplas camadas
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Application ‚îÇ -> ‚îÇ    Redis    ‚îÇ -> ‚îÇ PostgreSQL  ‚îÇ
‚îÇ   Memory    ‚îÇ    ‚îÇ   (L2)      ‚îÇ    ‚îÇ   (Source)  ‚îÇ
‚îÇ   (L1)      ‚îÇ    ‚îÇ             ‚îÇ    ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 2. **Database Optimization**
- **√çndices estrat√©gicos**: Queries otimizadas para busca de disponibilidade
- **Connection pooling**: Prisma com pool configurado
- **Query optimization**: Eager/lazy loading conforme necess√°rio

#### 3. **Rate Limiting Inteligente**
```typescript
// Rate limits diferenciados por contexto
const authLimits = { ttl: 60, limit: 5 };      // Login
const scheduleLimits = { ttl: 60, limit: 20 }; // Agendamentos
const searchLimits = { ttl: 60, limit: 100 };  // Busca
```

### Seguran√ßa por Design

#### 1. **Defense in Depth**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üõ°Ô∏è SECURITY LAYERS                                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Rate Limiting (DDoS protection)                         ‚îÇ
‚îÇ 2. Input Validation (Zod schemas)                          ‚îÇ
‚îÇ 3. Authentication (JWT tokens)                             ‚îÇ
‚îÇ 4. Authorization (Role-based access)                       ‚îÇ
‚îÇ 5. Data Sanitization (SQL injection prevention)           ‚îÇ
‚îÇ 6. Audit Logging (Event tracking)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 2. **Principle of Least Privilege**
- **Role-based access**: DOCTOR vs PATIENT permissions
- **Resource ownership**: Usu√°rios s√≥ acessam seus pr√≥prios dados
- **Route protection**: Guards em todas as rotas sens√≠veis

### Estrat√©gias de Escalabilidade

#### 1. **Horizontal Scaling Ready**
```typescript
// Stateless design + Redis para sess√µes
// PUB/SUB para sincroniza√ß√£o entre inst√¢ncias
// Load balancer friendly
```

#### 2. **Database Scaling**
- **Read replicas**: Queries de leitura distribu√≠das
- **Sharding friendly**: UUIDs como primary keys
- **Async processing**: Events para opera√ß√µes pesadas

#### 3. **Microservices Ready**
```typescript
// Arquitetura preparada para decomposi√ß√£o:
// - Auth Service
// - Doctor Service  
// - Schedule Service
// - Notification Service
```

### Qualidade e Manutenibilidade

#### 1. **Testing Strategy**
```
‚îú‚îÄ‚îÄ Unit Tests (Jest)
‚îÇ   ‚îú‚îÄ‚îÄ Services (business logic)
‚îÇ   ‚îú‚îÄ‚îÄ Repositories (data access)
‚îÇ   ‚îî‚îÄ‚îÄ Utilities (pure functions)
‚îú‚îÄ‚îÄ Integration Tests
‚îÇ   ‚îú‚îÄ‚îÄ API endpoints (e2e)
‚îÇ   ‚îú‚îÄ‚îÄ Database operations
‚îÇ   ‚îî‚îÄ‚îÄ Cache behavior
‚îî‚îÄ‚îÄ Contract Tests
    ‚îú‚îÄ‚îÄ DTO validation
    ‚îî‚îÄ‚îÄ API schemas
```

#### 2. **Code Quality**
- **Biome**: Linting e formata√ß√£o consistente
- **TypeScript**: Type safety em toda a aplica√ß√£o
- **Conventional commits**: Hist√≥rico organizado
- **Documentation**: Swagger autom√°tico + coment√°rios

#### 3. **Monitoring & Observability**
```typescript
// Preparado para:
// - Metrics (Prometheus)
// - Logging (structured logs)
// - Tracing (distributed tracing)
// - Health checks (k8s ready)
```

### Decis√µes de Trade-offs

#### ‚úÖ **Escolhas Feitas**
- **NestJS vs Express**: Estrutura + DI + Decorators
- **Prisma vs TypeORM**: Developer experience + type safety
- **Zod vs class-validator**: Runtime safety + schema reuse
- **Redis vs In-memory**: Distributed caching + persistence
- **JWT vs Sessions**: Stateless + microservices ready

#### ‚öñÔ∏è **Trade-offs Considerados**
- **Performance vs Maintainability**: Optamos por c√≥digo limpo
- **Flexibility vs Convention**: NestJS opinions aceitas
- **Simplicity vs Features**: Features essenciais implementadas
- **Memory vs Speed**: Cache estrat√©gico implementado

## ÔøΩüöÄ Tecnologias Utilizadas

- **Backend**: NestJS (Node.js + TypeScript)
- **Banco de Dados**: PostgreSQL
- **Cache**: Redis
- **ORM**: Prisma
- **Autentica√ß√£o**: JWT + Argon2
- **Valida√ß√£o**: Zod
- **Documenta√ß√£o**: OpenAPI/Swagger
- **Testes**: Jest
- **Code Quality**: Biome (linting + formatting)
- **Rate Limiting**: NestJS Throttler

## üìã Pr√©-requisitos

Antes de come√ßar, certifique-se de ter instalado:

- [Node.js](https://nodejs.org/) (vers√£o 18 ou superior)
- [pnpm](https://pnpm.io/) (vers√£o 8 ou superior)
- [Docker](https://www.docker.com/) e [Docker Compose](https://docs.docker.com/compose/)
- [Git](https://git-scm.com/)

## üõ†Ô∏è Configura√ß√£o do Ambiente

### 1. Clone o reposit√≥rio

```bash
git clone <url-do-repositorio>
cd vox-testing/api
```

### 2. Configure as vari√°veis de ambiente

Crie um arquivo `.env` na raiz do projeto baseado no exemplo:

```bash
cp .env.testing .env
```

Edite o arquivo `.env` com suas configura√ß√µes:

```env
# Porta da aplica√ß√£o
PORT=3000

# Configura√ß√µes do PostgreSQL
POSTGRESQL_USERNAME=vox_user
POSTGRESQL_PASSWORD=vox_password
POSTGRESQL_DATABASE=vox_testing
DATABASE_URL=postgresql://vox_user:vox_password@localhost:5432/vox_testing

# Seguran√ßa
ARGON_SECRET=your_super_secret_argon_key_here
JWT_PRIVATE_KEY=your_super_secret_jwt_private_key_here

# Redis
REDIS_URL=redis://localhost:6379/0
```

### 3. Instale as depend√™ncias

```bash
pnpm install
```

## üê≥ Execu√ß√£o com Docker (Recomendado)

### Op√ß√£o 1: Docker Compose Completo

Para subir toda a infraestrutura (PostgreSQL + Redis) de uma s√≥ vez:

```bash
# Inicia os servi√ßos de banco e cache
docker-compose up -d

# Aguarde alguns segundos para os containers inicializarem
sleep 10

# Execute as migra√ß√µes do banco
npx prisma migrate deploy

# Inicie a aplica√ß√£o
pnpm run start:dev
```

### Op√ß√£o 2: Apenas Infraestrutura

Se preferir rodar apenas o banco e cache no Docker:

```bash
# Inicia apenas PostgreSQL e Redis
docker-compose up -d vox-testing-db vox-testing-redis

# Execute o resto dos comandos normalmente
npx prisma migrate deploy
pnpm run start:dev
```

## üóÑÔ∏è Configura√ß√£o do Banco de Dados

### Executar migra√ß√µes

```bash
# Aplicar migra√ß√µes existentes
npx prisma migrate deploy

# Ou para desenvolvimento (cria nova migra√ß√£o se necess√°rio)
npx prisma migrate dev
```

### Gerar cliente Prisma

```bash
npx prisma generate
```

### Visualizar dados (Prisma Studio)

```bash
npx prisma studio
```

## üèÉ‚Äç‚ôÇÔ∏è Executando a Aplica√ß√£o

### Desenvolvimento

```bash
# Modo desenvolvimento com hot reload
pnpm run start:dev

# Modo debug
pnpm run start:debug
```

### Produ√ß√£o

```bash
# Build da aplica√ß√£o
pnpm run build

# Execu√ß√£o em produ√ß√£o
pnpm run start:prod
```

A API estar√° dispon√≠vel em: `http://localhost:3000`

## üìö Documenta√ß√£o da API

Ap√≥s iniciar a aplica√ß√£o, acesse:

- **Swagger UI**: `http://localhost:3000/api`
- **Scalar (alternativa)**: `http://localhost:3000/scalar`

## üß™ Testes

### Testes Unit√°rios

```bash
# Executar todos os testes
pnpm run test

# Executar em modo watch
pnpm run test:watch

# Executar com coverage
pnpm run test:coverage
```

### Testes E2E

```bash
# Setup completo dos testes E2E
pnpm run test:e2e:setup

# Ou execute manualmente:
docker-compose -f docker-compose.test.yml up -d
pnpm run db:test:migrate
pnpm run test:e2e
```

## üîß Scripts Dispon√≠veis

```bash
# Desenvolvimento
pnpm run start:dev          # Inicia em modo desenvolvimento
pnpm run start:debug        # Inicia em modo debug

# Build e produ√ß√£o
pnpm run build              # Build da aplica√ß√£o
pnpm run start:prod         # Execu√ß√£o em produ√ß√£o

# Qualidade de c√≥digo
pnpm run lint               # Executar linting e formata√ß√£o

# Testes
pnpm run test               # Testes unit√°rios
pnpm run test:watch         # Testes em modo watch
pnpm run test:coverage      # Testes com coverage
pnpm run test:e2e           # Testes E2E

# Banco de dados
pnpm run db:test:migrate    # Migra√ß√£o banco de teste
pnpm run db:test:reset      # Reset banco de teste
```

## üèóÔ∏è Estrutura do Projeto

```
src/
‚îú‚îÄ‚îÄ app.module.ts           # M√≥dulo principal
‚îú‚îÄ‚îÄ main.ts                 # Entry point da aplica√ß√£o
‚îú‚îÄ‚îÄ controllers/            # Controladores REST
‚îú‚îÄ‚îÄ services/               # L√≥gica de neg√≥cio
‚îú‚îÄ‚îÄ repositories/           # Camada de dados
‚îú‚îÄ‚îÄ dtos/                   # Data Transfer Objects
‚îú‚îÄ‚îÄ guards/                 # Guards de autentica√ß√£o/autoriza√ß√£o
‚îú‚îÄ‚îÄ interceptors/           # Interceptadores
‚îú‚îÄ‚îÄ errors/                 # Classes de erro customizadas
‚îú‚îÄ‚îÄ modules/                # M√≥dulos da aplica√ß√£o
‚îú‚îÄ‚îÄ utils/                  # Utilit√°rios
‚îî‚îÄ‚îÄ cache/                  # Implementa√ß√£o de cache
```

## üîê Funcionalidades de Seguran√ßa

- **Autentica√ß√£o JWT**: Tokens seguros para autentica√ß√£o
- **Hash de senhas**: Argon2 para hash seguro das senhas
- **Rate Limiting**: Prote√ß√£o contra spam/DoS
- **Valida√ß√£o de dados**: Zod para valida√ß√£o robusta
- **Controle de acesso**: Guards para m√©dicos e pacientes

## üöÄ Funcionalidades Principais

### Para M√©dicos
- Cadastro e login
- Gerenciamento de disponibilidade de hor√°rios
- Visualiza√ß√£o de agendamentos
- Atualiza√ß√£o de status dos agendamentos

### Para Pacientes
- Cadastro e login
- Visualiza√ß√£o de hor√°rios dispon√≠veis
- Cria√ß√£o de agendamentos
- Visualiza√ß√£o de agendamentos pr√≥prios

## üìã Mapa de Rotas da API

### üîê **Autentica√ß√£o** (`/auth`)
- `POST /auth/login` - Autenticar usu√°rio (m√©dico/paciente)
- `POST /auth/register` - Registrar novo usu√°rio
- `POST /auth/refresh` - Renovar token JWT

### üë• **Usu√°rios** (`/users`)
- `GET /users/me` - Obter dados do usu√°rio logado
- `PUT /users/me` - Atualizar dados do usu√°rio logado
- `DELETE /users/me` - Deletar conta do usu√°rio logado

### üë®‚Äç‚öïÔ∏è **M√©dicos** (`/doctors`)
- `DELETE /doctors` - Deletar perfil de m√©dico
- `GET /doctors/:id/exists` - Verificar se m√©dico existe

### üìÖ **Disponibilidades** (`/doctors/:doctorId/availability`)
- `POST /doctors/:doctorId/availability` - Criar disponibilidade
- `GET /doctors/:doctorId/availability` - Listar disponibilidades do m√©dico
- `PUT /doctors/:doctorId/availability/:id` - Atualizar disponibilidade
- `DELETE /doctors/:doctorId/availability/:id` - Deletar disponibilidade espec√≠fica
- `DELETE /doctors/:doctorId/availability` - Deletar todas disponibilidades do m√©dico

### üóìÔ∏è **Agendamentos** (`/schedules`)
- `POST /schedules` - Criar agendamento (pacientes)
- `GET /schedules/me` - Listar agendamentos do usu√°rio logado
- `GET /schedules/:id` - Obter agendamento por ID
- `PUT /schedules/:id/cancel` - Cancelar agendamento
- `PUT /schedules/:id/complete` - Marcar agendamento como conclu√≠do (m√©dicos)
- `DELETE /schedules/:id` - Deletar agendamento

### üîç **Busca de Hor√°rios** (`/availability`)
- `GET /availability/slots` - Buscar slots dispon√≠veis
  - Query params: `doctorId`, `date`, `startDate`, `endDate`

### üìä **Relat√≥rios**
- `GET /doctors/:doctorId/schedules` - Agendamentos do m√©dico

### üîß **Utilit√°rios**
- `GET /hello-world` - Verifica√ß√£o de sa√∫de da API

## üõ°Ô∏è Seguran√ßa Implementada

- **Autentica√ß√£o JWT** em todas as rotas (exceto auth)
- **Autoriza√ß√£o por perfil** (DOCTOR/PATIENT)
- **Rate limiting** implementado com @nestjs/throttler
- **Valida√ß√£o de DTOs** com Zod
- **Sanitiza√ß√£o de inputs**

### Rate Limiting Configurado
- **Autentica√ß√£o**: 5 tentativas/min (login), 3 tentativas/5min (register)
- **Agendamentos**: 20 cria√ß√µes/min por usu√°rio
- **Disponibilidades**: 15 cria√ß√µes/min por m√©dico
- **Consultas**: 100 requests/min para busca de hor√°rios

## üêõ Resolu√ß√£o de Problemas

### Erro de conex√£o com banco
- Verifique se o PostgreSQL est√° rodando: `docker ps`
- Confirme as credenciais no arquivo `.env`
- Teste a conex√£o: `npx prisma db pull`

### Erro de migra√ß√£o
```bash
# Reset completo do banco (cuidado em produ√ß√£o!)
npx prisma migrate reset --force

# Aplicar migra√ß√µes novamente
npx prisma migrate deploy
```

### Porta j√° em uso
```bash
# Verificar qual processo est√° usando a porta
lsof -ti:3000

# Matar o processo se necess√°rio
kill $(lsof -ti:3000)
```

## üìû Suporte

Para d√∫vidas ou problemas:

1. Verifique a documenta√ß√£o da API em `/api`
2. Consulte os logs da aplica√ß√£o
3. Execute os testes para validar o ambiente

## üìÑ Licen√ßa

Este projeto est√° sob a licen√ßa MIT. Veja o arquivo [LICENSE](LICENSE) para mais detalhes.

---

**Desenvolvido como parte do desafio t√©cnico para desenvolvedor(a) Full-Stack**